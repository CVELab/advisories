{
    "type": "bundle",
    "id": "bundle--46ffd455-0459-4c7a-b050-77813c3677f4",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--6bca3fd4-f104-433c-8be1-87f63fdc5c42",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2024-10-21T19:15:54.755855Z",
            "modified": "2024-10-21T19:15:54.755855Z",
            "name": "CVE-2024-49976",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing/timerlat: Drop interface_lock in stop_kthread()\n\nstop_kthread() is the offline callback for \"trace/osnoise:online\", since\ncommit 5bfbcd1ee57b (\"tracing/timerlat: Add interface_lock around clearing\nof kthread in stop_kthread()\"), the following ABBA deadlock scenario is\nintroduced:\n\nT1                            | T2 [BP]               | T3 [AP]\nosnoise_hotplug_workfn()      | work_for_cpu_fn()     | cpuhp_thread_fun()\n                              |   _cpu_down()         |   osnoise_cpu_die()\n  mutex_lock(&interface_lock) |                       |     stop_kthread()\n                              |     cpus_write_lock() |       mutex_lock(&interface_lock)\n  cpus_read_lock()            |     cpuhp_kick_ap()   |\n\nAs the interface_lock here in just for protecting the \"kthread\" field of\nthe osn_var, use xchg() instead to fix this issue. Also use\nfor_each_online_cpu() back in stop_per_cpu_kthreads() as it can take\ncpu_read_lock() again.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2024-49976"
                }
            ]
        }
    ]
}