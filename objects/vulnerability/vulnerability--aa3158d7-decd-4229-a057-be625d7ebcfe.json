{
    "type": "bundle",
    "id": "bundle--987e8fe7-9061-442f-9e12-f1df640df4fc",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--aa3158d7-decd-4229-a057-be625d7ebcfe",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2024-12-29T03:30:00.280224Z",
            "modified": "2024-12-29T03:30:00.280224Z",
            "name": "CVE-2024-56694",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: fix recursive lock when verdict program return SK_PASS\n\nWhen the stream_verdict program returns SK_PASS, it places the received skb\ninto its own receive queue, but a recursive lock eventually occurs, leading\nto an operating system deadlock. This issue has been present since v6.9.\n\n'''\nsk_psock_strp_data_ready\n    write_lock_bh(&sk->sk_callback_lock)\n    strp_data_ready\n      strp_read_sock\n        read_sock -> tcp_read_sock\n          strp_recv\n            cb.rcv_msg -> sk_psock_strp_read\n              # now stream_verdict return SK_PASS without peer sock assign\n              __SK_PASS = sk_psock_map_verd(SK_PASS, NULL)\n              sk_psock_verdict_apply\n                sk_psock_skb_ingress_self\n                  sk_psock_skb_ingress_enqueue\n                    sk_psock_data_ready\n                      read_lock_bh(&sk->sk_callback_lock) <= dead lock\n\n'''\n\nThis topic has been discussed before, but it has not been fixed.\nPrevious discussion:\nhttps://lore.kernel.org/all/6684a5864ec86_403d20898@john.notmuch",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2024-56694"
                }
            ]
        }
    ]
}