{
    "type": "bundle",
    "id": "bundle--e71c3998-7b94-40a6-8658-025d8d1852fc",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--5a188924-bd87-4c6e-acc3-28dac68d4ce7",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2025-03-27T17:18:51.456107Z",
            "modified": "2025-03-27T17:18:51.456107Z",
            "name": "CVE-2023-53007",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\ntracing: Make sure trace_printk() can output as soon as it can be used\n\nCurrently trace_printk() can be used as soon as early_trace_init() is\ncalled from start_kernel(). But if a crash happens, and\n\"ftrace_dump_on_oops\" is set on the kernel command line, all you get will\nbe:\n\n  [    0.456075]   <idle>-0         0dN.2. 347519us : Unknown type 6\n  [    0.456075]   <idle>-0         0dN.2. 353141us : Unknown type 6\n  [    0.456075]   <idle>-0         0dN.2. 358684us : Unknown type 6\n\nThis is because the trace_printk() event (type 6) hasn't been registered\nyet. That gets done via an early_initcall(), which may be early, but not\nearly enough.\n\nInstead of registering the trace_printk() event (and other ftrace events,\nwhich are not trace events) via an early_initcall(), have them registered at\nthe same time that trace_printk() can be used. This way, if there is a\ncrash before early_initcall(), then the trace_printk()s will actually be\nuseful.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2023-53007"
                }
            ]
        }
    ]
}