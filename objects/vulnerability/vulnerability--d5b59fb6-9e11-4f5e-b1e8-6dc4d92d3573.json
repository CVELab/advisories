{
    "type": "bundle",
    "id": "bundle--f416877a-f244-451a-9bd8-91c18ba763f8",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--d5b59fb6-9e11-4f5e-b1e8-6dc4d92d3573",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2025-02-26T02:52:57.657278Z",
            "modified": "2025-02-26T02:52:57.657278Z",
            "name": "CVE-2022-49200",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: btmtksdio: Fix kernel oops in btmtksdio_interrupt\n\nFix the following kernel oops in btmtksdio_interrrupt\n\n[   14.339134]  btmtksdio_interrupt+0x28/0x54\n[   14.339139]  process_sdio_pending_irqs+0x68/0x1a0\n[   14.339144]  sdio_irq_work+0x40/0x70\n[   14.339154]  process_one_work+0x184/0x39c\n[   14.339160]  worker_thread+0x228/0x3e8\n[   14.339168]  kthread+0x148/0x3ac\n[   14.339176]  ret_from_fork+0x10/0x30\n\nThat happened because hdev->power_on is already called before\nsdio_set_drvdata which btmtksdio_interrupt handler relies on is not\nproperly set up.\n\nThe details are shown as the below: hci_register_dev would run\nqueue_work(hdev->req_workqueue, &hdev->power_on) as WQ_HIGHPRI\nworkqueue_struct to complete the power-on sequeunce and thus hci_power_on\nmay run before sdio_set_drvdata is done in btmtksdio_probe.\n\nThe hci_dev_do_open in hci_power_on would initialize the device and enable\nthe interrupt and thus it is possible that btmtksdio_interrupt is being\ncalled right before sdio_set_drvdata is filled out.\n\nWhen btmtksdio_interrupt is being called and sdio_set_drvdata is not filled\n, the kernel oops is going to happen because btmtksdio_interrupt access an\nuninitialized pointer.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2022-49200"
                }
            ]
        }
    ]
}