{
    "type": "bundle",
    "id": "bundle--27e6f54d-57ee-4af7-9ba1-52fff3334a6e",
    "objects": [
        {
            "type": "vulnerability",
            "spec_version": "2.1",
            "id": "vulnerability--63dccb6f-ac44-4cb3-8153-31aa4cef042f",
            "created_by_ref": "identity--8ce3f695-d5a4-4dc8-9e93-a65af453a31a",
            "created": "2024-07-16T12:32:52.492905Z",
            "modified": "2024-07-16T12:32:52.492905Z",
            "name": "CVE-2022-48809",
            "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: fix a memleak when uncloning an skb dst and its metadata\n\nWhen uncloning an skb dst and its associated metadata, a new\ndst+metadata is allocated and later replaces the old one in the skb.\nThis is helpful to have a non-shared dst+metadata attached to a specific\nskb.\n\nThe issue is the uncloned dst+metadata is initialized with a refcount of\n1, which is increased to 2 before attaching it to the skb. When\ntun_dst_unclone returns, the dst+metadata is only referenced from a\nsingle place (the skb) while its refcount is 2. Its refcount will never\ndrop to 0 (when the skb is consumed), leading to a memory leak.\n\nFix this by removing the call to dst_hold in tun_dst_unclone, as the\ndst+metadata refcount is already 1.",
            "external_references": [
                {
                    "source_name": "cve",
                    "external_id": "CVE-2022-48809"
                }
            ]
        }
    ]
}